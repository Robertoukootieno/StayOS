<?php
/**
 * OperationsApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Noventrix StayOS API
 *
 * # Noventrix StayOS - Comprehensive Hospitality Management API  **Version:** 1.0.0   **Status:** Production Ready   **Last Updated:** 2025-12-18  ## Overview  StayOS provides a complete RESTful API for hospitality management, covering: - Property & Inventory Management - Reservation & Booking Lifecycle - Guest Profiles & Loyalty - Operations (Housekeeping & Maintenance) - Billing & Payments - Compliance & Audit - Channel Management & Distribution  ## Architecture Principles  - **RESTful Design:** Resource-oriented URLs, HTTP verbs, standard status codes - **HATEOAS:** Hypermedia links for discoverability - **Idempotency:** Safe retries using idempotency keys - **Versioning:** URL-based versioning (/v1/, /v2/) - **Pagination:** Cursor-based for large datasets - **Filtering:** Rich query parameters following JSON:API conventions - **Rate Limiting:** Token bucket algorithm (100 req/min standard, 1000 req/min premium)  ## Authentication & Security  - **OAuth 2.0 + OpenID Connect** for user authentication - **API Keys** for server-to-server integration - **JWT Bearer Tokens** with short expiry (15 minutes) - **Refresh Tokens** for session management - **Scopes** for fine-grained authorization - **mTLS** for high-security integrations  ## Error Handling  All errors follow RFC 7807 (Problem Details for HTTP APIs): ```json {   \"type\": \"https://api.stayos.com/errors/validation-error\",   \"title\": \"Validation Failed\",   \"status\": 400,   \"detail\": \"Check-out date must be after check-in date\",   \"instance\": \"/reservations/create\",   \"traceId\": \"550e8400-e29b-41d4-a716-446655440000\",   \"errors\": [     {       \"field\": \"checkOutDate\",       \"code\": \"INVALID_DATE_RANGE\",       \"message\": \"Check-out date must be after check-in date\"     }   ] } ```  ## Rate Limiting  - **Header:** `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset` - **Status Code:** 429 Too Many Requests - **Retry-After:** Seconds until rate limit resets  ## Webhooks  StayOS supports webhooks for real-time event notifications. See `/webhooks` endpoints.  ## Support  - **Documentation:** https://docs.stayos.com - **API Status:** https://status.stayos.com - **Support:** api-support@noventrix.com
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: api-support@noventrix.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.18.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * OperationsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class OperationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'acknowledgeServiceRequest' => [
            'application/json',
        ],
        'addIncidentAction' => [
            'application/json',
        ],
        'assignHousekeepingTask' => [
            'application/json',
        ],
        'assignMaintenanceRequest' => [
            'application/json',
        ],
        'assignServiceRequest' => [
            'application/json',
        ],
        'cancelServiceRequest' => [
            'application/json',
        ],
        'clockInShift' => [
            'application/json',
        ],
        'clockOutShift' => [
            'application/json',
        ],
        'closeIncident' => [
            'application/json',
        ],
        'completeHousekeepingTask' => [
            'application/json',
        ],
        'completeMaintenanceRequest' => [
            'application/json',
        ],
        'completeServiceRequest' => [
            'application/json',
        ],
        'completeTraining' => [
            'application/json',
        ],
        'createHousekeepingTask' => [
            'application/json',
        ],
        'createMaintenanceRequest' => [
            'application/json',
        ],
        'createServiceRequest' => [
            'application/json',
        ],
        'createStaffShift' => [
            'application/json',
        ],
        'createTrainingModule' => [
            'application/json',
        ],
        'enrollInTraining' => [
            'application/json',
        ],
        'escalateServiceRequest' => [
            'application/json',
        ],
        'failHousekeepingTask' => [
            'application/json',
        ],
        'getCleaningSchedule' => [
            'application/json',
        ],
        'getIncident' => [
            'application/json',
        ],
        'getMaintenanceHistory' => [
            'application/json',
        ],
        'getStaffPerformance' => [
            'application/json',
        ],
        'getTrainingEnrollment' => [
            'application/json',
        ],
        'getTrainingModule' => [
            'application/json',
        ],
        'listHousekeepingTasks' => [
            'application/json',
        ],
        'listIncidents' => [
            'application/json',
        ],
        'listMaintenanceRequests' => [
            'application/json',
        ],
        'listServiceRequests' => [
            'application/json',
        ],
        'listStaffShifts' => [
            'application/json',
        ],
        'listTrainingModules' => [
            'application/json',
        ],
        'replaceHousekeepingTask' => [
            'application/json',
        ],
        'replaceIncident' => [
            'application/json',
        ],
        'replaceMaintenanceRequest' => [
            'application/json',
        ],
        'replaceServiceRequest' => [
            'application/json',
        ],
        'reportIncident' => [
            'application/json',
        ],
        'startHousekeepingTask' => [
            'application/json',
        ],
        'updateHousekeepingTask' => [
            'application/json',
        ],
        'updateMaintenanceRequest' => [
            'application/json',
        ],
        'updateServiceRequest' => [
            'application/json',
        ],
        'verifyHousekeepingTask' => [
            'application/json',
        ],
        'verifyMaintenanceRequest' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation acknowledgeServiceRequest
     *
     * Acknowledge service request
     *
     * @param  string $request_id request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acknowledgeServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function acknowledgeServiceRequest($request_id, string $contentType = self::contentTypes['acknowledgeServiceRequest'][0])
    {
        list($response) = $this->acknowledgeServiceRequestWithHttpInfo($request_id, $contentType);
        return $response;
    }

    /**
     * Operation acknowledgeServiceRequestWithHttpInfo
     *
     * Acknowledge service request
     *
     * @param  string $request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acknowledgeServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function acknowledgeServiceRequestWithHttpInfo($request_id, string $contentType = self::contentTypes['acknowledgeServiceRequest'][0])
    {
        $request = $this->acknowledgeServiceRequestRequest($request_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ServiceRequest',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation acknowledgeServiceRequestAsync
     *
     * Acknowledge service request
     *
     * @param  string $request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acknowledgeServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acknowledgeServiceRequestAsync($request_id, string $contentType = self::contentTypes['acknowledgeServiceRequest'][0])
    {
        return $this->acknowledgeServiceRequestAsyncWithHttpInfo($request_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation acknowledgeServiceRequestAsyncWithHttpInfo
     *
     * Acknowledge service request
     *
     * @param  string $request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acknowledgeServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function acknowledgeServiceRequestAsyncWithHttpInfo($request_id, string $contentType = self::contentTypes['acknowledgeServiceRequest'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceRequest';
        $request = $this->acknowledgeServiceRequestRequest($request_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'acknowledgeServiceRequest'
     *
     * @param  string $request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['acknowledgeServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function acknowledgeServiceRequestRequest($request_id, string $contentType = self::contentTypes['acknowledgeServiceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling acknowledgeServiceRequest'
            );
        }


        $resourcePath = '/service-requests/{requestId}/acknowledge';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addIncidentAction
     *
     * Add incident action
     *
     * @param  string $incident_id incident_id (required)
     * @param  \OpenAPI\Client\Model\AddIncidentActionRequest $add_incident_action_request add_incident_action_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addIncidentAction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function addIncidentAction($incident_id, $add_incident_action_request, string $contentType = self::contentTypes['addIncidentAction'][0])
    {
        list($response) = $this->addIncidentActionWithHttpInfo($incident_id, $add_incident_action_request, $contentType);
        return $response;
    }

    /**
     * Operation addIncidentActionWithHttpInfo
     *
     * Add incident action
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\AddIncidentActionRequest $add_incident_action_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addIncidentAction'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function addIncidentActionWithHttpInfo($incident_id, $add_incident_action_request, string $contentType = self::contentTypes['addIncidentAction'][0])
    {
        $request = $this->addIncidentActionRequest($incident_id, $add_incident_action_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Incident',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\Incident',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Incident',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addIncidentActionAsync
     *
     * Add incident action
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\AddIncidentActionRequest $add_incident_action_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addIncidentAction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addIncidentActionAsync($incident_id, $add_incident_action_request, string $contentType = self::contentTypes['addIncidentAction'][0])
    {
        return $this->addIncidentActionAsyncWithHttpInfo($incident_id, $add_incident_action_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addIncidentActionAsyncWithHttpInfo
     *
     * Add incident action
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\AddIncidentActionRequest $add_incident_action_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addIncidentAction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addIncidentActionAsyncWithHttpInfo($incident_id, $add_incident_action_request, string $contentType = self::contentTypes['addIncidentAction'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Incident';
        $request = $this->addIncidentActionRequest($incident_id, $add_incident_action_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addIncidentAction'
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\AddIncidentActionRequest $add_incident_action_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addIncidentAction'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addIncidentActionRequest($incident_id, $add_incident_action_request, string $contentType = self::contentTypes['addIncidentAction'][0])
    {

        // verify the required parameter 'incident_id' is set
        if ($incident_id === null || (is_array($incident_id) && count($incident_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $incident_id when calling addIncidentAction'
            );
        }

        // verify the required parameter 'add_incident_action_request' is set
        if ($add_incident_action_request === null || (is_array($add_incident_action_request) && count($add_incident_action_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_incident_action_request when calling addIncidentAction'
            );
        }


        $resourcePath = '/incidents/{incidentId}/actions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($incident_id !== null) {
            $resourcePath = str_replace(
                '{' . 'incidentId' . '}',
                ObjectSerializer::toPathValue($incident_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_incident_action_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_incident_action_request));
            } else {
                $httpBody = $add_incident_action_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation assignHousekeepingTask
     *
     * Assign housekeeping task
     *
     * @param  string $task_id task_id (required)
     * @param  \OpenAPI\Client\Model\AssignHousekeepingTaskRequest $assign_housekeeping_task_request assign_housekeeping_task_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function assignHousekeepingTask($task_id, $assign_housekeeping_task_request, string $contentType = self::contentTypes['assignHousekeepingTask'][0])
    {
        list($response) = $this->assignHousekeepingTaskWithHttpInfo($task_id, $assign_housekeeping_task_request, $contentType);
        return $response;
    }

    /**
     * Operation assignHousekeepingTaskWithHttpInfo
     *
     * Assign housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\AssignHousekeepingTaskRequest $assign_housekeeping_task_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignHousekeepingTaskWithHttpInfo($task_id, $assign_housekeeping_task_request, string $contentType = self::contentTypes['assignHousekeepingTask'][0])
    {
        $request = $this->assignHousekeepingTaskRequest($task_id, $assign_housekeeping_task_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HousekeepingTask',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation assignHousekeepingTaskAsync
     *
     * Assign housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\AssignHousekeepingTaskRequest $assign_housekeeping_task_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignHousekeepingTaskAsync($task_id, $assign_housekeeping_task_request, string $contentType = self::contentTypes['assignHousekeepingTask'][0])
    {
        return $this->assignHousekeepingTaskAsyncWithHttpInfo($task_id, $assign_housekeeping_task_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignHousekeepingTaskAsyncWithHttpInfo
     *
     * Assign housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\AssignHousekeepingTaskRequest $assign_housekeeping_task_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignHousekeepingTaskAsyncWithHttpInfo($task_id, $assign_housekeeping_task_request, string $contentType = self::contentTypes['assignHousekeepingTask'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HousekeepingTask';
        $request = $this->assignHousekeepingTaskRequest($task_id, $assign_housekeeping_task_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignHousekeepingTask'
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\AssignHousekeepingTaskRequest $assign_housekeeping_task_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function assignHousekeepingTaskRequest($task_id, $assign_housekeeping_task_request, string $contentType = self::contentTypes['assignHousekeepingTask'][0])
    {

        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling assignHousekeepingTask'
            );
        }

        // verify the required parameter 'assign_housekeeping_task_request' is set
        if ($assign_housekeeping_task_request === null || (is_array($assign_housekeeping_task_request) && count($assign_housekeeping_task_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assign_housekeeping_task_request when calling assignHousekeepingTask'
            );
        }


        $resourcePath = '/housekeeping/tasks/{taskId}/assign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($assign_housekeeping_task_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($assign_housekeeping_task_request));
            } else {
                $httpBody = $assign_housekeeping_task_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation assignMaintenanceRequest
     *
     * Assign maintenance request
     *
     * @param  string $request_id request_id (required)
     * @param  \OpenAPI\Client\Model\AssignMaintenanceRequestRequest $assign_maintenance_request_request assign_maintenance_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MaintenanceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function assignMaintenanceRequest($request_id, $assign_maintenance_request_request, string $contentType = self::contentTypes['assignMaintenanceRequest'][0])
    {
        list($response) = $this->assignMaintenanceRequestWithHttpInfo($request_id, $assign_maintenance_request_request, $contentType);
        return $response;
    }

    /**
     * Operation assignMaintenanceRequestWithHttpInfo
     *
     * Assign maintenance request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\AssignMaintenanceRequestRequest $assign_maintenance_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MaintenanceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignMaintenanceRequestWithHttpInfo($request_id, $assign_maintenance_request_request, string $contentType = self::contentTypes['assignMaintenanceRequest'][0])
    {
        $request = $this->assignMaintenanceRequestRequest($request_id, $assign_maintenance_request_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MaintenanceRequest',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MaintenanceRequest',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MaintenanceRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation assignMaintenanceRequestAsync
     *
     * Assign maintenance request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\AssignMaintenanceRequestRequest $assign_maintenance_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignMaintenanceRequestAsync($request_id, $assign_maintenance_request_request, string $contentType = self::contentTypes['assignMaintenanceRequest'][0])
    {
        return $this->assignMaintenanceRequestAsyncWithHttpInfo($request_id, $assign_maintenance_request_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignMaintenanceRequestAsyncWithHttpInfo
     *
     * Assign maintenance request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\AssignMaintenanceRequestRequest $assign_maintenance_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignMaintenanceRequestAsyncWithHttpInfo($request_id, $assign_maintenance_request_request, string $contentType = self::contentTypes['assignMaintenanceRequest'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MaintenanceRequest';
        $request = $this->assignMaintenanceRequestRequest($request_id, $assign_maintenance_request_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignMaintenanceRequest'
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\AssignMaintenanceRequestRequest $assign_maintenance_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function assignMaintenanceRequestRequest($request_id, $assign_maintenance_request_request, string $contentType = self::contentTypes['assignMaintenanceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling assignMaintenanceRequest'
            );
        }

        // verify the required parameter 'assign_maintenance_request_request' is set
        if ($assign_maintenance_request_request === null || (is_array($assign_maintenance_request_request) && count($assign_maintenance_request_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assign_maintenance_request_request when calling assignMaintenanceRequest'
            );
        }


        $resourcePath = '/maintenance/requests/{requestId}/assign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($assign_maintenance_request_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($assign_maintenance_request_request));
            } else {
                $httpBody = $assign_maintenance_request_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation assignServiceRequest
     *
     * Assign service request
     *
     * @param  string $request_id request_id (required)
     * @param  \OpenAPI\Client\Model\AssignServiceRequestRequest $assign_service_request_request assign_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function assignServiceRequest($request_id, $assign_service_request_request, string $contentType = self::contentTypes['assignServiceRequest'][0])
    {
        list($response) = $this->assignServiceRequestWithHttpInfo($request_id, $assign_service_request_request, $contentType);
        return $response;
    }

    /**
     * Operation assignServiceRequestWithHttpInfo
     *
     * Assign service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\AssignServiceRequestRequest $assign_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignServiceRequestWithHttpInfo($request_id, $assign_service_request_request, string $contentType = self::contentTypes['assignServiceRequest'][0])
    {
        $request = $this->assignServiceRequestRequest($request_id, $assign_service_request_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ServiceRequest',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation assignServiceRequestAsync
     *
     * Assign service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\AssignServiceRequestRequest $assign_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignServiceRequestAsync($request_id, $assign_service_request_request, string $contentType = self::contentTypes['assignServiceRequest'][0])
    {
        return $this->assignServiceRequestAsyncWithHttpInfo($request_id, $assign_service_request_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assignServiceRequestAsyncWithHttpInfo
     *
     * Assign service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\AssignServiceRequestRequest $assign_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assignServiceRequestAsyncWithHttpInfo($request_id, $assign_service_request_request, string $contentType = self::contentTypes['assignServiceRequest'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceRequest';
        $request = $this->assignServiceRequestRequest($request_id, $assign_service_request_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'assignServiceRequest'
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\AssignServiceRequestRequest $assign_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['assignServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function assignServiceRequestRequest($request_id, $assign_service_request_request, string $contentType = self::contentTypes['assignServiceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling assignServiceRequest'
            );
        }

        // verify the required parameter 'assign_service_request_request' is set
        if ($assign_service_request_request === null || (is_array($assign_service_request_request) && count($assign_service_request_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $assign_service_request_request when calling assignServiceRequest'
            );
        }


        $resourcePath = '/service-requests/{requestId}/assign';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($assign_service_request_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($assign_service_request_request));
            } else {
                $httpBody = $assign_service_request_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cancelServiceRequest
     *
     * Cancel service request
     *
     * @param  string $request_id request_id (required)
     * @param  \OpenAPI\Client\Model\CancelServiceRequestRequest|null $cancel_service_request_request cancel_service_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function cancelServiceRequest($request_id, $cancel_service_request_request = null, string $contentType = self::contentTypes['cancelServiceRequest'][0])
    {
        list($response) = $this->cancelServiceRequestWithHttpInfo($request_id, $cancel_service_request_request, $contentType);
        return $response;
    }

    /**
     * Operation cancelServiceRequestWithHttpInfo
     *
     * Cancel service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\CancelServiceRequestRequest|null $cancel_service_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function cancelServiceRequestWithHttpInfo($request_id, $cancel_service_request_request = null, string $contentType = self::contentTypes['cancelServiceRequest'][0])
    {
        $request = $this->cancelServiceRequestRequest($request_id, $cancel_service_request_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ServiceRequest',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation cancelServiceRequestAsync
     *
     * Cancel service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\CancelServiceRequestRequest|null $cancel_service_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelServiceRequestAsync($request_id, $cancel_service_request_request = null, string $contentType = self::contentTypes['cancelServiceRequest'][0])
    {
        return $this->cancelServiceRequestAsyncWithHttpInfo($request_id, $cancel_service_request_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cancelServiceRequestAsyncWithHttpInfo
     *
     * Cancel service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\CancelServiceRequestRequest|null $cancel_service_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cancelServiceRequestAsyncWithHttpInfo($request_id, $cancel_service_request_request = null, string $contentType = self::contentTypes['cancelServiceRequest'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceRequest';
        $request = $this->cancelServiceRequestRequest($request_id, $cancel_service_request_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cancelServiceRequest'
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\CancelServiceRequestRequest|null $cancel_service_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cancelServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cancelServiceRequestRequest($request_id, $cancel_service_request_request = null, string $contentType = self::contentTypes['cancelServiceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling cancelServiceRequest'
            );
        }



        $resourcePath = '/service-requests/{requestId}/cancel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($cancel_service_request_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cancel_service_request_request));
            } else {
                $httpBody = $cancel_service_request_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clockInShift
     *
     * Clock in for shift
     *
     * @param  string $shift_id shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockInShift'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StaffShift|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function clockInShift($shift_id, string $contentType = self::contentTypes['clockInShift'][0])
    {
        list($response) = $this->clockInShiftWithHttpInfo($shift_id, $contentType);
        return $response;
    }

    /**
     * Operation clockInShiftWithHttpInfo
     *
     * Clock in for shift
     *
     * @param  string $shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockInShift'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StaffShift|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function clockInShiftWithHttpInfo($shift_id, string $contentType = self::contentTypes['clockInShift'][0])
    {
        $request = $this->clockInShiftRequest($shift_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StaffShift',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StaffShift',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StaffShift',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation clockInShiftAsync
     *
     * Clock in for shift
     *
     * @param  string $shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockInShift'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clockInShiftAsync($shift_id, string $contentType = self::contentTypes['clockInShift'][0])
    {
        return $this->clockInShiftAsyncWithHttpInfo($shift_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clockInShiftAsyncWithHttpInfo
     *
     * Clock in for shift
     *
     * @param  string $shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockInShift'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clockInShiftAsyncWithHttpInfo($shift_id, string $contentType = self::contentTypes['clockInShift'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StaffShift';
        $request = $this->clockInShiftRequest($shift_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clockInShift'
     *
     * @param  string $shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockInShift'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clockInShiftRequest($shift_id, string $contentType = self::contentTypes['clockInShift'][0])
    {

        // verify the required parameter 'shift_id' is set
        if ($shift_id === null || (is_array($shift_id) && count($shift_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shift_id when calling clockInShift'
            );
        }


        $resourcePath = '/staff/shifts/{shiftId}/clock-in';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($shift_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shiftId' . '}',
                ObjectSerializer::toPathValue($shift_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clockOutShift
     *
     * Clock out from shift
     *
     * @param  string $shift_id shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockOutShift'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StaffShift|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function clockOutShift($shift_id, string $contentType = self::contentTypes['clockOutShift'][0])
    {
        list($response) = $this->clockOutShiftWithHttpInfo($shift_id, $contentType);
        return $response;
    }

    /**
     * Operation clockOutShiftWithHttpInfo
     *
     * Clock out from shift
     *
     * @param  string $shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockOutShift'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StaffShift|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function clockOutShiftWithHttpInfo($shift_id, string $contentType = self::contentTypes['clockOutShift'][0])
    {
        $request = $this->clockOutShiftRequest($shift_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StaffShift',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StaffShift',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StaffShift',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation clockOutShiftAsync
     *
     * Clock out from shift
     *
     * @param  string $shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockOutShift'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clockOutShiftAsync($shift_id, string $contentType = self::contentTypes['clockOutShift'][0])
    {
        return $this->clockOutShiftAsyncWithHttpInfo($shift_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clockOutShiftAsyncWithHttpInfo
     *
     * Clock out from shift
     *
     * @param  string $shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockOutShift'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clockOutShiftAsyncWithHttpInfo($shift_id, string $contentType = self::contentTypes['clockOutShift'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StaffShift';
        $request = $this->clockOutShiftRequest($shift_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clockOutShift'
     *
     * @param  string $shift_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['clockOutShift'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function clockOutShiftRequest($shift_id, string $contentType = self::contentTypes['clockOutShift'][0])
    {

        // verify the required parameter 'shift_id' is set
        if ($shift_id === null || (is_array($shift_id) && count($shift_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $shift_id when calling clockOutShift'
            );
        }


        $resourcePath = '/staff/shifts/{shiftId}/clock-out';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($shift_id !== null) {
            $resourcePath = str_replace(
                '{' . 'shiftId' . '}',
                ObjectSerializer::toPathValue($shift_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation closeIncident
     *
     * Close incident
     *
     * @param  string $incident_id incident_id (required)
     * @param  \OpenAPI\Client\Model\CloseIncidentRequest|null $close_incident_request close_incident_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeIncident'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function closeIncident($incident_id, $close_incident_request = null, string $contentType = self::contentTypes['closeIncident'][0])
    {
        list($response) = $this->closeIncidentWithHttpInfo($incident_id, $close_incident_request, $contentType);
        return $response;
    }

    /**
     * Operation closeIncidentWithHttpInfo
     *
     * Close incident
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\CloseIncidentRequest|null $close_incident_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeIncident'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function closeIncidentWithHttpInfo($incident_id, $close_incident_request = null, string $contentType = self::contentTypes['closeIncident'][0])
    {
        $request = $this->closeIncidentRequest($incident_id, $close_incident_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Incident',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\Incident',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Incident',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation closeIncidentAsync
     *
     * Close incident
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\CloseIncidentRequest|null $close_incident_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeIncidentAsync($incident_id, $close_incident_request = null, string $contentType = self::contentTypes['closeIncident'][0])
    {
        return $this->closeIncidentAsyncWithHttpInfo($incident_id, $close_incident_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation closeIncidentAsyncWithHttpInfo
     *
     * Close incident
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\CloseIncidentRequest|null $close_incident_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeIncidentAsyncWithHttpInfo($incident_id, $close_incident_request = null, string $contentType = self::contentTypes['closeIncident'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Incident';
        $request = $this->closeIncidentRequest($incident_id, $close_incident_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'closeIncident'
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\CloseIncidentRequest|null $close_incident_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function closeIncidentRequest($incident_id, $close_incident_request = null, string $contentType = self::contentTypes['closeIncident'][0])
    {

        // verify the required parameter 'incident_id' is set
        if ($incident_id === null || (is_array($incident_id) && count($incident_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $incident_id when calling closeIncident'
            );
        }



        $resourcePath = '/incidents/{incidentId}/close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($incident_id !== null) {
            $resourcePath = str_replace(
                '{' . 'incidentId' . '}',
                ObjectSerializer::toPathValue($incident_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($close_incident_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($close_incident_request));
            } else {
                $httpBody = $close_incident_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation completeHousekeepingTask
     *
     * Complete housekeeping task
     *
     * @param  string $task_id task_id (required)
     * @param  \OpenAPI\Client\Model\CompleteHousekeepingTaskRequest|null $complete_housekeeping_task_request complete_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function completeHousekeepingTask($task_id, $complete_housekeeping_task_request = null, string $contentType = self::contentTypes['completeHousekeepingTask'][0])
    {
        list($response) = $this->completeHousekeepingTaskWithHttpInfo($task_id, $complete_housekeeping_task_request, $contentType);
        return $response;
    }

    /**
     * Operation completeHousekeepingTaskWithHttpInfo
     *
     * Complete housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\CompleteHousekeepingTaskRequest|null $complete_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function completeHousekeepingTaskWithHttpInfo($task_id, $complete_housekeeping_task_request = null, string $contentType = self::contentTypes['completeHousekeepingTask'][0])
    {
        $request = $this->completeHousekeepingTaskRequest($task_id, $complete_housekeeping_task_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HousekeepingTask',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation completeHousekeepingTaskAsync
     *
     * Complete housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\CompleteHousekeepingTaskRequest|null $complete_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeHousekeepingTaskAsync($task_id, $complete_housekeeping_task_request = null, string $contentType = self::contentTypes['completeHousekeepingTask'][0])
    {
        return $this->completeHousekeepingTaskAsyncWithHttpInfo($task_id, $complete_housekeeping_task_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation completeHousekeepingTaskAsyncWithHttpInfo
     *
     * Complete housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\CompleteHousekeepingTaskRequest|null $complete_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeHousekeepingTaskAsyncWithHttpInfo($task_id, $complete_housekeeping_task_request = null, string $contentType = self::contentTypes['completeHousekeepingTask'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HousekeepingTask';
        $request = $this->completeHousekeepingTaskRequest($task_id, $complete_housekeeping_task_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'completeHousekeepingTask'
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\CompleteHousekeepingTaskRequest|null $complete_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function completeHousekeepingTaskRequest($task_id, $complete_housekeeping_task_request = null, string $contentType = self::contentTypes['completeHousekeepingTask'][0])
    {

        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling completeHousekeepingTask'
            );
        }



        $resourcePath = '/housekeeping/tasks/{taskId}/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($complete_housekeeping_task_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($complete_housekeeping_task_request));
            } else {
                $httpBody = $complete_housekeeping_task_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation completeMaintenanceRequest
     *
     * Complete maintenance request
     *
     * @param  string $request_id request_id (required)
     * @param  \OpenAPI\Client\Model\CompleteMaintenanceRequestRequest|null $complete_maintenance_request_request complete_maintenance_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MaintenanceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function completeMaintenanceRequest($request_id, $complete_maintenance_request_request = null, string $contentType = self::contentTypes['completeMaintenanceRequest'][0])
    {
        list($response) = $this->completeMaintenanceRequestWithHttpInfo($request_id, $complete_maintenance_request_request, $contentType);
        return $response;
    }

    /**
     * Operation completeMaintenanceRequestWithHttpInfo
     *
     * Complete maintenance request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\CompleteMaintenanceRequestRequest|null $complete_maintenance_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MaintenanceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function completeMaintenanceRequestWithHttpInfo($request_id, $complete_maintenance_request_request = null, string $contentType = self::contentTypes['completeMaintenanceRequest'][0])
    {
        $request = $this->completeMaintenanceRequestRequest($request_id, $complete_maintenance_request_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MaintenanceRequest',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MaintenanceRequest',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MaintenanceRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation completeMaintenanceRequestAsync
     *
     * Complete maintenance request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\CompleteMaintenanceRequestRequest|null $complete_maintenance_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeMaintenanceRequestAsync($request_id, $complete_maintenance_request_request = null, string $contentType = self::contentTypes['completeMaintenanceRequest'][0])
    {
        return $this->completeMaintenanceRequestAsyncWithHttpInfo($request_id, $complete_maintenance_request_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation completeMaintenanceRequestAsyncWithHttpInfo
     *
     * Complete maintenance request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\CompleteMaintenanceRequestRequest|null $complete_maintenance_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeMaintenanceRequestAsyncWithHttpInfo($request_id, $complete_maintenance_request_request = null, string $contentType = self::contentTypes['completeMaintenanceRequest'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MaintenanceRequest';
        $request = $this->completeMaintenanceRequestRequest($request_id, $complete_maintenance_request_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'completeMaintenanceRequest'
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\CompleteMaintenanceRequestRequest|null $complete_maintenance_request_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function completeMaintenanceRequestRequest($request_id, $complete_maintenance_request_request = null, string $contentType = self::contentTypes['completeMaintenanceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling completeMaintenanceRequest'
            );
        }



        $resourcePath = '/maintenance/requests/{requestId}/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($complete_maintenance_request_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($complete_maintenance_request_request));
            } else {
                $httpBody = $complete_maintenance_request_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation completeServiceRequest
     *
     * Complete service request
     *
     * @param  string $request_id request_id (required)
     * @param  \OpenAPI\Client\Model\MarkReservationNoShowRequest|null $mark_reservation_no_show_request mark_reservation_no_show_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function completeServiceRequest($request_id, $mark_reservation_no_show_request = null, string $contentType = self::contentTypes['completeServiceRequest'][0])
    {
        list($response) = $this->completeServiceRequestWithHttpInfo($request_id, $mark_reservation_no_show_request, $contentType);
        return $response;
    }

    /**
     * Operation completeServiceRequestWithHttpInfo
     *
     * Complete service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\MarkReservationNoShowRequest|null $mark_reservation_no_show_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function completeServiceRequestWithHttpInfo($request_id, $mark_reservation_no_show_request = null, string $contentType = self::contentTypes['completeServiceRequest'][0])
    {
        $request = $this->completeServiceRequestRequest($request_id, $mark_reservation_no_show_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ServiceRequest',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation completeServiceRequestAsync
     *
     * Complete service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\MarkReservationNoShowRequest|null $mark_reservation_no_show_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeServiceRequestAsync($request_id, $mark_reservation_no_show_request = null, string $contentType = self::contentTypes['completeServiceRequest'][0])
    {
        return $this->completeServiceRequestAsyncWithHttpInfo($request_id, $mark_reservation_no_show_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation completeServiceRequestAsyncWithHttpInfo
     *
     * Complete service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\MarkReservationNoShowRequest|null $mark_reservation_no_show_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeServiceRequestAsyncWithHttpInfo($request_id, $mark_reservation_no_show_request = null, string $contentType = self::contentTypes['completeServiceRequest'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceRequest';
        $request = $this->completeServiceRequestRequest($request_id, $mark_reservation_no_show_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'completeServiceRequest'
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\MarkReservationNoShowRequest|null $mark_reservation_no_show_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function completeServiceRequestRequest($request_id, $mark_reservation_no_show_request = null, string $contentType = self::contentTypes['completeServiceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling completeServiceRequest'
            );
        }



        $resourcePath = '/service-requests/{requestId}/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mark_reservation_no_show_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mark_reservation_no_show_request));
            } else {
                $httpBody = $mark_reservation_no_show_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation completeTraining
     *
     * Complete training
     *
     * @param  string $enrollment_id enrollment_id (required)
     * @param  \OpenAPI\Client\Model\CompleteTrainingRequest|null $complete_training_request complete_training_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeTraining'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TrainingEnrollment|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function completeTraining($enrollment_id, $complete_training_request = null, string $contentType = self::contentTypes['completeTraining'][0])
    {
        list($response) = $this->completeTrainingWithHttpInfo($enrollment_id, $complete_training_request, $contentType);
        return $response;
    }

    /**
     * Operation completeTrainingWithHttpInfo
     *
     * Complete training
     *
     * @param  string $enrollment_id (required)
     * @param  \OpenAPI\Client\Model\CompleteTrainingRequest|null $complete_training_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeTraining'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TrainingEnrollment|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function completeTrainingWithHttpInfo($enrollment_id, $complete_training_request = null, string $contentType = self::contentTypes['completeTraining'][0])
    {
        $request = $this->completeTrainingRequest($enrollment_id, $complete_training_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TrainingEnrollment',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TrainingEnrollment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TrainingEnrollment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation completeTrainingAsync
     *
     * Complete training
     *
     * @param  string $enrollment_id (required)
     * @param  \OpenAPI\Client\Model\CompleteTrainingRequest|null $complete_training_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeTraining'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeTrainingAsync($enrollment_id, $complete_training_request = null, string $contentType = self::contentTypes['completeTraining'][0])
    {
        return $this->completeTrainingAsyncWithHttpInfo($enrollment_id, $complete_training_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation completeTrainingAsyncWithHttpInfo
     *
     * Complete training
     *
     * @param  string $enrollment_id (required)
     * @param  \OpenAPI\Client\Model\CompleteTrainingRequest|null $complete_training_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeTraining'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeTrainingAsyncWithHttpInfo($enrollment_id, $complete_training_request = null, string $contentType = self::contentTypes['completeTraining'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TrainingEnrollment';
        $request = $this->completeTrainingRequest($enrollment_id, $complete_training_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'completeTraining'
     *
     * @param  string $enrollment_id (required)
     * @param  \OpenAPI\Client\Model\CompleteTrainingRequest|null $complete_training_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeTraining'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function completeTrainingRequest($enrollment_id, $complete_training_request = null, string $contentType = self::contentTypes['completeTraining'][0])
    {

        // verify the required parameter 'enrollment_id' is set
        if ($enrollment_id === null || (is_array($enrollment_id) && count($enrollment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enrollment_id when calling completeTraining'
            );
        }



        $resourcePath = '/training/enrollments/{enrollmentId}/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enrollment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'enrollmentId' . '}',
                ObjectSerializer::toPathValue($enrollment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($complete_training_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($complete_training_request));
            } else {
                $httpBody = $complete_training_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createHousekeepingTask
     *
     * Create housekeeping task
     *
     * @param  object $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function createHousekeepingTask($body, string $contentType = self::contentTypes['createHousekeepingTask'][0])
    {
        list($response) = $this->createHousekeepingTaskWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation createHousekeepingTaskWithHttpInfo
     *
     * Create housekeeping task
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function createHousekeepingTaskWithHttpInfo($body, string $contentType = self::contentTypes['createHousekeepingTask'][0])
    {
        $request = $this->createHousekeepingTaskRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createHousekeepingTaskAsync
     *
     * Create housekeeping task
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHousekeepingTaskAsync($body, string $contentType = self::contentTypes['createHousekeepingTask'][0])
    {
        return $this->createHousekeepingTaskAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createHousekeepingTaskAsyncWithHttpInfo
     *
     * Create housekeeping task
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHousekeepingTaskAsyncWithHttpInfo($body, string $contentType = self::contentTypes['createHousekeepingTask'][0])
    {
        $returnType = 'object';
        $request = $this->createHousekeepingTaskRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createHousekeepingTask'
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createHousekeepingTaskRequest($body, string $contentType = self::contentTypes['createHousekeepingTask'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createHousekeepingTask'
            );
        }


        $resourcePath = '/housekeeping/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMaintenanceRequest
     *
     * Create maintenance request
     *
     * @param  object $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function createMaintenanceRequest($body, string $contentType = self::contentTypes['createMaintenanceRequest'][0])
    {
        list($response) = $this->createMaintenanceRequestWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation createMaintenanceRequestWithHttpInfo
     *
     * Create maintenance request
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMaintenanceRequestWithHttpInfo($body, string $contentType = self::contentTypes['createMaintenanceRequest'][0])
    {
        $request = $this->createMaintenanceRequestRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createMaintenanceRequestAsync
     *
     * Create maintenance request
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMaintenanceRequestAsync($body, string $contentType = self::contentTypes['createMaintenanceRequest'][0])
    {
        return $this->createMaintenanceRequestAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMaintenanceRequestAsyncWithHttpInfo
     *
     * Create maintenance request
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMaintenanceRequestAsyncWithHttpInfo($body, string $contentType = self::contentTypes['createMaintenanceRequest'][0])
    {
        $returnType = 'object';
        $request = $this->createMaintenanceRequestRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMaintenanceRequest'
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createMaintenanceRequestRequest($body, string $contentType = self::contentTypes['createMaintenanceRequest'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createMaintenanceRequest'
            );
        }


        $resourcePath = '/maintenance/requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createServiceRequest
     *
     * Create service request
     *
     * @param  object $body body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function createServiceRequest($body, string $contentType = self::contentTypes['createServiceRequest'][0])
    {
        list($response) = $this->createServiceRequestWithHttpInfo($body, $contentType);
        return $response;
    }

    /**
     * Operation createServiceRequestWithHttpInfo
     *
     * Create service request
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function createServiceRequestWithHttpInfo($body, string $contentType = self::contentTypes['createServiceRequest'][0])
    {
        $request = $this->createServiceRequestRequest($body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createServiceRequestAsync
     *
     * Create service request
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createServiceRequestAsync($body, string $contentType = self::contentTypes['createServiceRequest'][0])
    {
        return $this->createServiceRequestAsyncWithHttpInfo($body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createServiceRequestAsyncWithHttpInfo
     *
     * Create service request
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createServiceRequestAsyncWithHttpInfo($body, string $contentType = self::contentTypes['createServiceRequest'][0])
    {
        $returnType = 'object';
        $request = $this->createServiceRequestRequest($body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createServiceRequest'
     *
     * @param  object $body (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createServiceRequestRequest($body, string $contentType = self::contentTypes['createServiceRequest'][0])
    {

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createServiceRequest'
            );
        }


        $resourcePath = '/service-requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStaffShift
     *
     * Create staff shift
     *
     * @param  \OpenAPI\Client\Model\StaffShift $staff_shift staff_shift (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStaffShift'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StaffShift|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function createStaffShift($staff_shift, string $contentType = self::contentTypes['createStaffShift'][0])
    {
        list($response) = $this->createStaffShiftWithHttpInfo($staff_shift, $contentType);
        return $response;
    }

    /**
     * Operation createStaffShiftWithHttpInfo
     *
     * Create staff shift
     *
     * @param  \OpenAPI\Client\Model\StaffShift $staff_shift (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStaffShift'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StaffShift|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function createStaffShiftWithHttpInfo($staff_shift, string $contentType = self::contentTypes['createStaffShift'][0])
    {
        $request = $this->createStaffShiftRequest($staff_shift, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StaffShift',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StaffShift',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StaffShift',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createStaffShiftAsync
     *
     * Create staff shift
     *
     * @param  \OpenAPI\Client\Model\StaffShift $staff_shift (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStaffShift'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStaffShiftAsync($staff_shift, string $contentType = self::contentTypes['createStaffShift'][0])
    {
        return $this->createStaffShiftAsyncWithHttpInfo($staff_shift, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStaffShiftAsyncWithHttpInfo
     *
     * Create staff shift
     *
     * @param  \OpenAPI\Client\Model\StaffShift $staff_shift (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStaffShift'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStaffShiftAsyncWithHttpInfo($staff_shift, string $contentType = self::contentTypes['createStaffShift'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StaffShift';
        $request = $this->createStaffShiftRequest($staff_shift, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStaffShift'
     *
     * @param  \OpenAPI\Client\Model\StaffShift $staff_shift (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createStaffShift'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createStaffShiftRequest($staff_shift, string $contentType = self::contentTypes['createStaffShift'][0])
    {

        // verify the required parameter 'staff_shift' is set
        if ($staff_shift === null || (is_array($staff_shift) && count($staff_shift) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $staff_shift when calling createStaffShift'
            );
        }


        $resourcePath = '/staff/shifts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($staff_shift)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($staff_shift));
            } else {
                $httpBody = $staff_shift;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTrainingModule
     *
     * Create training module
     *
     * @param  \OpenAPI\Client\Model\TrainingModule $training_module training_module (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTrainingModule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TrainingModule|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function createTrainingModule($training_module, string $contentType = self::contentTypes['createTrainingModule'][0])
    {
        list($response) = $this->createTrainingModuleWithHttpInfo($training_module, $contentType);
        return $response;
    }

    /**
     * Operation createTrainingModuleWithHttpInfo
     *
     * Create training module
     *
     * @param  \OpenAPI\Client\Model\TrainingModule $training_module (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTrainingModule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TrainingModule|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTrainingModuleWithHttpInfo($training_module, string $contentType = self::contentTypes['createTrainingModule'][0])
    {
        $request = $this->createTrainingModuleRequest($training_module, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TrainingModule',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TrainingModule',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TrainingModule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTrainingModuleAsync
     *
     * Create training module
     *
     * @param  \OpenAPI\Client\Model\TrainingModule $training_module (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTrainingModule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTrainingModuleAsync($training_module, string $contentType = self::contentTypes['createTrainingModule'][0])
    {
        return $this->createTrainingModuleAsyncWithHttpInfo($training_module, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTrainingModuleAsyncWithHttpInfo
     *
     * Create training module
     *
     * @param  \OpenAPI\Client\Model\TrainingModule $training_module (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTrainingModule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTrainingModuleAsyncWithHttpInfo($training_module, string $contentType = self::contentTypes['createTrainingModule'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TrainingModule';
        $request = $this->createTrainingModuleRequest($training_module, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTrainingModule'
     *
     * @param  \OpenAPI\Client\Model\TrainingModule $training_module (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTrainingModule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTrainingModuleRequest($training_module, string $contentType = self::contentTypes['createTrainingModule'][0])
    {

        // verify the required parameter 'training_module' is set
        if ($training_module === null || (is_array($training_module) && count($training_module) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $training_module when calling createTrainingModule'
            );
        }


        $resourcePath = '/training/modules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($training_module)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($training_module));
            } else {
                $httpBody = $training_module;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enrollInTraining
     *
     * Enroll in training
     *
     * @param  \OpenAPI\Client\Model\TrainingEnrollment $training_enrollment training_enrollment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enrollInTraining'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TrainingEnrollment|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function enrollInTraining($training_enrollment, string $contentType = self::contentTypes['enrollInTraining'][0])
    {
        list($response) = $this->enrollInTrainingWithHttpInfo($training_enrollment, $contentType);
        return $response;
    }

    /**
     * Operation enrollInTrainingWithHttpInfo
     *
     * Enroll in training
     *
     * @param  \OpenAPI\Client\Model\TrainingEnrollment $training_enrollment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enrollInTraining'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TrainingEnrollment|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function enrollInTrainingWithHttpInfo($training_enrollment, string $contentType = self::contentTypes['enrollInTraining'][0])
    {
        $request = $this->enrollInTrainingRequest($training_enrollment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TrainingEnrollment',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TrainingEnrollment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TrainingEnrollment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation enrollInTrainingAsync
     *
     * Enroll in training
     *
     * @param  \OpenAPI\Client\Model\TrainingEnrollment $training_enrollment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enrollInTraining'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enrollInTrainingAsync($training_enrollment, string $contentType = self::contentTypes['enrollInTraining'][0])
    {
        return $this->enrollInTrainingAsyncWithHttpInfo($training_enrollment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enrollInTrainingAsyncWithHttpInfo
     *
     * Enroll in training
     *
     * @param  \OpenAPI\Client\Model\TrainingEnrollment $training_enrollment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enrollInTraining'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enrollInTrainingAsyncWithHttpInfo($training_enrollment, string $contentType = self::contentTypes['enrollInTraining'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TrainingEnrollment';
        $request = $this->enrollInTrainingRequest($training_enrollment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enrollInTraining'
     *
     * @param  \OpenAPI\Client\Model\TrainingEnrollment $training_enrollment (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enrollInTraining'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enrollInTrainingRequest($training_enrollment, string $contentType = self::contentTypes['enrollInTraining'][0])
    {

        // verify the required parameter 'training_enrollment' is set
        if ($training_enrollment === null || (is_array($training_enrollment) && count($training_enrollment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $training_enrollment when calling enrollInTraining'
            );
        }


        $resourcePath = '/training/enrollments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($training_enrollment)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($training_enrollment));
            } else {
                $httpBody = $training_enrollment;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation escalateServiceRequest
     *
     * Escalate service request
     *
     * @param  string $request_id request_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['escalateServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function escalateServiceRequest($request_id, $escalate_service_request_request, string $contentType = self::contentTypes['escalateServiceRequest'][0])
    {
        list($response) = $this->escalateServiceRequestWithHttpInfo($request_id, $escalate_service_request_request, $contentType);
        return $response;
    }

    /**
     * Operation escalateServiceRequestWithHttpInfo
     *
     * Escalate service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['escalateServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ServiceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function escalateServiceRequestWithHttpInfo($request_id, $escalate_service_request_request, string $contentType = self::contentTypes['escalateServiceRequest'][0])
    {
        $request = $this->escalateServiceRequestRequest($request_id, $escalate_service_request_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ServiceRequest',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ServiceRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation escalateServiceRequestAsync
     *
     * Escalate service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['escalateServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function escalateServiceRequestAsync($request_id, $escalate_service_request_request, string $contentType = self::contentTypes['escalateServiceRequest'][0])
    {
        return $this->escalateServiceRequestAsyncWithHttpInfo($request_id, $escalate_service_request_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation escalateServiceRequestAsyncWithHttpInfo
     *
     * Escalate service request
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['escalateServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function escalateServiceRequestAsyncWithHttpInfo($request_id, $escalate_service_request_request, string $contentType = self::contentTypes['escalateServiceRequest'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ServiceRequest';
        $request = $this->escalateServiceRequestRequest($request_id, $escalate_service_request_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'escalateServiceRequest'
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['escalateServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function escalateServiceRequestRequest($request_id, $escalate_service_request_request, string $contentType = self::contentTypes['escalateServiceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling escalateServiceRequest'
            );
        }

        // verify the required parameter 'escalate_service_request_request' is set
        if ($escalate_service_request_request === null || (is_array($escalate_service_request_request) && count($escalate_service_request_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $escalate_service_request_request when calling escalateServiceRequest'
            );
        }


        $resourcePath = '/service-requests/{requestId}/escalate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($escalate_service_request_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($escalate_service_request_request));
            } else {
                $httpBody = $escalate_service_request_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation failHousekeepingTask
     *
     * Fail housekeeping task
     *
     * @param  string $task_id task_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['failHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function failHousekeepingTask($task_id, $escalate_service_request_request, string $contentType = self::contentTypes['failHousekeepingTask'][0])
    {
        list($response) = $this->failHousekeepingTaskWithHttpInfo($task_id, $escalate_service_request_request, $contentType);
        return $response;
    }

    /**
     * Operation failHousekeepingTaskWithHttpInfo
     *
     * Fail housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['failHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function failHousekeepingTaskWithHttpInfo($task_id, $escalate_service_request_request, string $contentType = self::contentTypes['failHousekeepingTask'][0])
    {
        $request = $this->failHousekeepingTaskRequest($task_id, $escalate_service_request_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HousekeepingTask',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation failHousekeepingTaskAsync
     *
     * Fail housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['failHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function failHousekeepingTaskAsync($task_id, $escalate_service_request_request, string $contentType = self::contentTypes['failHousekeepingTask'][0])
    {
        return $this->failHousekeepingTaskAsyncWithHttpInfo($task_id, $escalate_service_request_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation failHousekeepingTaskAsyncWithHttpInfo
     *
     * Fail housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['failHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function failHousekeepingTaskAsyncWithHttpInfo($task_id, $escalate_service_request_request, string $contentType = self::contentTypes['failHousekeepingTask'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HousekeepingTask';
        $request = $this->failHousekeepingTaskRequest($task_id, $escalate_service_request_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'failHousekeepingTask'
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\EscalateServiceRequestRequest $escalate_service_request_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['failHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function failHousekeepingTaskRequest($task_id, $escalate_service_request_request, string $contentType = self::contentTypes['failHousekeepingTask'][0])
    {

        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling failHousekeepingTask'
            );
        }

        // verify the required parameter 'escalate_service_request_request' is set
        if ($escalate_service_request_request === null || (is_array($escalate_service_request_request) && count($escalate_service_request_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $escalate_service_request_request when calling failHousekeepingTask'
            );
        }


        $resourcePath = '/housekeeping/tasks/{taskId}/fail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($escalate_service_request_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($escalate_service_request_request));
            } else {
                $httpBody = $escalate_service_request_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getCleaningSchedule
     *
     * Get cleaning schedule
     *
     * @param  string $property_id property_id (required)
     * @param  \DateTime|null $date date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleaningSchedule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetCleaningSchedule200Response|\OpenAPI\Client\Model\Model0
     */
    public function getCleaningSchedule($property_id, $date = null, string $contentType = self::contentTypes['getCleaningSchedule'][0])
    {
        list($response) = $this->getCleaningScheduleWithHttpInfo($property_id, $date, $contentType);
        return $response;
    }

    /**
     * Operation getCleaningScheduleWithHttpInfo
     *
     * Get cleaning schedule
     *
     * @param  string $property_id (required)
     * @param  \DateTime|null $date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleaningSchedule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetCleaningSchedule200Response|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function getCleaningScheduleWithHttpInfo($property_id, $date = null, string $contentType = self::contentTypes['getCleaningSchedule'][0])
    {
        $request = $this->getCleaningScheduleRequest($property_id, $date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetCleaningSchedule200Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\GetCleaningSchedule200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetCleaningSchedule200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getCleaningScheduleAsync
     *
     * Get cleaning schedule
     *
     * @param  string $property_id (required)
     * @param  \DateTime|null $date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleaningSchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCleaningScheduleAsync($property_id, $date = null, string $contentType = self::contentTypes['getCleaningSchedule'][0])
    {
        return $this->getCleaningScheduleAsyncWithHttpInfo($property_id, $date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getCleaningScheduleAsyncWithHttpInfo
     *
     * Get cleaning schedule
     *
     * @param  string $property_id (required)
     * @param  \DateTime|null $date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleaningSchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getCleaningScheduleAsyncWithHttpInfo($property_id, $date = null, string $contentType = self::contentTypes['getCleaningSchedule'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetCleaningSchedule200Response';
        $request = $this->getCleaningScheduleRequest($property_id, $date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getCleaningSchedule'
     *
     * @param  string $property_id (required)
     * @param  \DateTime|null $date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getCleaningSchedule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getCleaningScheduleRequest($property_id, $date = null, string $contentType = self::contentTypes['getCleaningSchedule'][0])
    {

        // verify the required parameter 'property_id' is set
        if ($property_id === null || (is_array($property_id) && count($property_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $property_id when calling getCleaningSchedule'
            );
        }



        $resourcePath = '/housekeeping/schedule';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getIncident
     *
     * Get incident details
     *
     * @param  string $incident_id incident_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIncident'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function getIncident($incident_id, string $contentType = self::contentTypes['getIncident'][0])
    {
        list($response) = $this->getIncidentWithHttpInfo($incident_id, $contentType);
        return $response;
    }

    /**
     * Operation getIncidentWithHttpInfo
     *
     * Get incident details
     *
     * @param  string $incident_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIncident'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function getIncidentWithHttpInfo($incident_id, string $contentType = self::contentTypes['getIncident'][0])
    {
        $request = $this->getIncidentRequest($incident_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Incident',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\Incident',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Incident',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getIncidentAsync
     *
     * Get incident details
     *
     * @param  string $incident_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIncidentAsync($incident_id, string $contentType = self::contentTypes['getIncident'][0])
    {
        return $this->getIncidentAsyncWithHttpInfo($incident_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getIncidentAsyncWithHttpInfo
     *
     * Get incident details
     *
     * @param  string $incident_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getIncidentAsyncWithHttpInfo($incident_id, string $contentType = self::contentTypes['getIncident'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Incident';
        $request = $this->getIncidentRequest($incident_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getIncident'
     *
     * @param  string $incident_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getIncidentRequest($incident_id, string $contentType = self::contentTypes['getIncident'][0])
    {

        // verify the required parameter 'incident_id' is set
        if ($incident_id === null || (is_array($incident_id) && count($incident_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $incident_id when calling getIncident'
            );
        }


        $resourcePath = '/incidents/{incidentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($incident_id !== null) {
            $resourcePath = str_replace(
                '{' . 'incidentId' . '}',
                ObjectSerializer::toPathValue($incident_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMaintenanceHistory
     *
     * Get maintenance history
     *
     * @param  string $request_id request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMaintenanceHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetMaintenanceHistory200Response|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function getMaintenanceHistory($request_id, string $contentType = self::contentTypes['getMaintenanceHistory'][0])
    {
        list($response) = $this->getMaintenanceHistoryWithHttpInfo($request_id, $contentType);
        return $response;
    }

    /**
     * Operation getMaintenanceHistoryWithHttpInfo
     *
     * Get maintenance history
     *
     * @param  string $request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMaintenanceHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetMaintenanceHistory200Response|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMaintenanceHistoryWithHttpInfo($request_id, string $contentType = self::contentTypes['getMaintenanceHistory'][0])
    {
        $request = $this->getMaintenanceHistoryRequest($request_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetMaintenanceHistory200Response',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\GetMaintenanceHistory200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetMaintenanceHistory200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMaintenanceHistoryAsync
     *
     * Get maintenance history
     *
     * @param  string $request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMaintenanceHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMaintenanceHistoryAsync($request_id, string $contentType = self::contentTypes['getMaintenanceHistory'][0])
    {
        return $this->getMaintenanceHistoryAsyncWithHttpInfo($request_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMaintenanceHistoryAsyncWithHttpInfo
     *
     * Get maintenance history
     *
     * @param  string $request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMaintenanceHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMaintenanceHistoryAsyncWithHttpInfo($request_id, string $contentType = self::contentTypes['getMaintenanceHistory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetMaintenanceHistory200Response';
        $request = $this->getMaintenanceHistoryRequest($request_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMaintenanceHistory'
     *
     * @param  string $request_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMaintenanceHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMaintenanceHistoryRequest($request_id, string $contentType = self::contentTypes['getMaintenanceHistory'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling getMaintenanceHistory'
            );
        }


        $resourcePath = '/maintenance/requests/{requestId}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getStaffPerformance
     *
     * Get staff performance metrics
     *
     * @param  string $staff_id staff_id (required)
     * @param  \DateTime|null $start_date start_date (optional)
     * @param  \DateTime|null $end_date end_date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStaffPerformance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetStaffPerformance200Response|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function getStaffPerformance($staff_id, $start_date = null, $end_date = null, string $contentType = self::contentTypes['getStaffPerformance'][0])
    {
        list($response) = $this->getStaffPerformanceWithHttpInfo($staff_id, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation getStaffPerformanceWithHttpInfo
     *
     * Get staff performance metrics
     *
     * @param  string $staff_id (required)
     * @param  \DateTime|null $start_date (optional)
     * @param  \DateTime|null $end_date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStaffPerformance'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetStaffPerformance200Response|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function getStaffPerformanceWithHttpInfo($staff_id, $start_date = null, $end_date = null, string $contentType = self::contentTypes['getStaffPerformance'][0])
    {
        $request = $this->getStaffPerformanceRequest($staff_id, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetStaffPerformance200Response',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\GetStaffPerformance200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetStaffPerformance200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getStaffPerformanceAsync
     *
     * Get staff performance metrics
     *
     * @param  string $staff_id (required)
     * @param  \DateTime|null $start_date (optional)
     * @param  \DateTime|null $end_date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStaffPerformance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStaffPerformanceAsync($staff_id, $start_date = null, $end_date = null, string $contentType = self::contentTypes['getStaffPerformance'][0])
    {
        return $this->getStaffPerformanceAsyncWithHttpInfo($staff_id, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getStaffPerformanceAsyncWithHttpInfo
     *
     * Get staff performance metrics
     *
     * @param  string $staff_id (required)
     * @param  \DateTime|null $start_date (optional)
     * @param  \DateTime|null $end_date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStaffPerformance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getStaffPerformanceAsyncWithHttpInfo($staff_id, $start_date = null, $end_date = null, string $contentType = self::contentTypes['getStaffPerformance'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetStaffPerformance200Response';
        $request = $this->getStaffPerformanceRequest($staff_id, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getStaffPerformance'
     *
     * @param  string $staff_id (required)
     * @param  \DateTime|null $start_date (optional)
     * @param  \DateTime|null $end_date (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getStaffPerformance'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getStaffPerformanceRequest($staff_id, $start_date = null, $end_date = null, string $contentType = self::contentTypes['getStaffPerformance'][0])
    {

        // verify the required parameter 'staff_id' is set
        if ($staff_id === null || (is_array($staff_id) && count($staff_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $staff_id when calling getStaffPerformance'
            );
        }




        $resourcePath = '/staff/{staffId}/performance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($staff_id !== null) {
            $resourcePath = str_replace(
                '{' . 'staffId' . '}',
                ObjectSerializer::toPathValue($staff_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTrainingEnrollment
     *
     * Get enrollment details
     *
     * @param  string $enrollment_id enrollment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingEnrollment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TrainingEnrollment|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function getTrainingEnrollment($enrollment_id, string $contentType = self::contentTypes['getTrainingEnrollment'][0])
    {
        list($response) = $this->getTrainingEnrollmentWithHttpInfo($enrollment_id, $contentType);
        return $response;
    }

    /**
     * Operation getTrainingEnrollmentWithHttpInfo
     *
     * Get enrollment details
     *
     * @param  string $enrollment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingEnrollment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TrainingEnrollment|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTrainingEnrollmentWithHttpInfo($enrollment_id, string $contentType = self::contentTypes['getTrainingEnrollment'][0])
    {
        $request = $this->getTrainingEnrollmentRequest($enrollment_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TrainingEnrollment',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TrainingEnrollment',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TrainingEnrollment',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTrainingEnrollmentAsync
     *
     * Get enrollment details
     *
     * @param  string $enrollment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingEnrollment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrainingEnrollmentAsync($enrollment_id, string $contentType = self::contentTypes['getTrainingEnrollment'][0])
    {
        return $this->getTrainingEnrollmentAsyncWithHttpInfo($enrollment_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTrainingEnrollmentAsyncWithHttpInfo
     *
     * Get enrollment details
     *
     * @param  string $enrollment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingEnrollment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrainingEnrollmentAsyncWithHttpInfo($enrollment_id, string $contentType = self::contentTypes['getTrainingEnrollment'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TrainingEnrollment';
        $request = $this->getTrainingEnrollmentRequest($enrollment_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTrainingEnrollment'
     *
     * @param  string $enrollment_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingEnrollment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTrainingEnrollmentRequest($enrollment_id, string $contentType = self::contentTypes['getTrainingEnrollment'][0])
    {

        // verify the required parameter 'enrollment_id' is set
        if ($enrollment_id === null || (is_array($enrollment_id) && count($enrollment_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $enrollment_id when calling getTrainingEnrollment'
            );
        }


        $resourcePath = '/training/enrollments/{enrollmentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($enrollment_id !== null) {
            $resourcePath = str_replace(
                '{' . 'enrollmentId' . '}',
                ObjectSerializer::toPathValue($enrollment_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTrainingModule
     *
     * Get training module details
     *
     * @param  string $module_id module_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingModule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TrainingModule|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function getTrainingModule($module_id, string $contentType = self::contentTypes['getTrainingModule'][0])
    {
        list($response) = $this->getTrainingModuleWithHttpInfo($module_id, $contentType);
        return $response;
    }

    /**
     * Operation getTrainingModuleWithHttpInfo
     *
     * Get training module details
     *
     * @param  string $module_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingModule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TrainingModule|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTrainingModuleWithHttpInfo($module_id, string $contentType = self::contentTypes['getTrainingModule'][0])
    {
        $request = $this->getTrainingModuleRequest($module_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TrainingModule',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TrainingModule',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TrainingModule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTrainingModuleAsync
     *
     * Get training module details
     *
     * @param  string $module_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingModule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrainingModuleAsync($module_id, string $contentType = self::contentTypes['getTrainingModule'][0])
    {
        return $this->getTrainingModuleAsyncWithHttpInfo($module_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTrainingModuleAsyncWithHttpInfo
     *
     * Get training module details
     *
     * @param  string $module_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingModule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrainingModuleAsyncWithHttpInfo($module_id, string $contentType = self::contentTypes['getTrainingModule'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TrainingModule';
        $request = $this->getTrainingModuleRequest($module_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTrainingModule'
     *
     * @param  string $module_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrainingModule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTrainingModuleRequest($module_id, string $contentType = self::contentTypes['getTrainingModule'][0])
    {

        // verify the required parameter 'module_id' is set
        if ($module_id === null || (is_array($module_id) && count($module_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $module_id when calling getTrainingModule'
            );
        }


        $resourcePath = '/training/modules/{moduleId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($module_id !== null) {
            $resourcePath = str_replace(
                '{' . 'moduleId' . '}',
                ObjectSerializer::toPathValue($module_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listHousekeepingTasks
     *
     * List housekeeping tasks
     *
     * @param  string|null $property_id property_id (optional)
     * @param  string|null $status status (optional)
     * @param  string|null $assigned_to assigned_to (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHousekeepingTasks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetGuestStays200Response|\OpenAPI\Client\Model\Model0
     */
    public function listHousekeepingTasks($property_id = null, $status = null, $assigned_to = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listHousekeepingTasks'][0])
    {
        list($response) = $this->listHousekeepingTasksWithHttpInfo($property_id, $status, $assigned_to, $page_size, $cursor, $contentType);
        return $response;
    }

    /**
     * Operation listHousekeepingTasksWithHttpInfo
     *
     * List housekeeping tasks
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  string|null $assigned_to (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHousekeepingTasks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetGuestStays200Response|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function listHousekeepingTasksWithHttpInfo($property_id = null, $status = null, $assigned_to = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listHousekeepingTasks'][0])
    {
        $request = $this->listHousekeepingTasksRequest($property_id, $status, $assigned_to, $page_size, $cursor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetGuestStays200Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\GetGuestStays200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetGuestStays200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listHousekeepingTasksAsync
     *
     * List housekeeping tasks
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  string|null $assigned_to (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHousekeepingTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHousekeepingTasksAsync($property_id = null, $status = null, $assigned_to = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listHousekeepingTasks'][0])
    {
        return $this->listHousekeepingTasksAsyncWithHttpInfo($property_id, $status, $assigned_to, $page_size, $cursor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listHousekeepingTasksAsyncWithHttpInfo
     *
     * List housekeeping tasks
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  string|null $assigned_to (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHousekeepingTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listHousekeepingTasksAsyncWithHttpInfo($property_id = null, $status = null, $assigned_to = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listHousekeepingTasks'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetGuestStays200Response';
        $request = $this->listHousekeepingTasksRequest($property_id, $status, $assigned_to, $page_size, $cursor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listHousekeepingTasks'
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  string|null $assigned_to (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listHousekeepingTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listHousekeepingTasksRequest($property_id = null, $status = null, $assigned_to = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listHousekeepingTasks'][0])
    {




        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listHousekeepingTasks, must be smaller than or equal to 100.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listHousekeepingTasks, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/housekeeping/tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $assigned_to,
            'assignedTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listIncidents
     *
     * List incidents
     *
     * @param  string|null $property_id property_id (optional)
     * @param  string|null $severity severity (optional)
     * @param  string|null $status status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncidents'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListIncidents200Response|\OpenAPI\Client\Model\Model0
     */
    public function listIncidents($property_id = null, $severity = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listIncidents'][0])
    {
        list($response) = $this->listIncidentsWithHttpInfo($property_id, $severity, $status, $page_size, $cursor, $contentType);
        return $response;
    }

    /**
     * Operation listIncidentsWithHttpInfo
     *
     * List incidents
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $severity (optional)
     * @param  string|null $status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncidents'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListIncidents200Response|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function listIncidentsWithHttpInfo($property_id = null, $severity = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listIncidents'][0])
    {
        $request = $this->listIncidentsRequest($property_id, $severity, $status, $page_size, $cursor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ListIncidents200Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ListIncidents200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListIncidents200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listIncidentsAsync
     *
     * List incidents
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $severity (optional)
     * @param  string|null $status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncidents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIncidentsAsync($property_id = null, $severity = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listIncidents'][0])
    {
        return $this->listIncidentsAsyncWithHttpInfo($property_id, $severity, $status, $page_size, $cursor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listIncidentsAsyncWithHttpInfo
     *
     * List incidents
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $severity (optional)
     * @param  string|null $status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncidents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listIncidentsAsyncWithHttpInfo($property_id = null, $severity = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listIncidents'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListIncidents200Response';
        $request = $this->listIncidentsRequest($property_id, $severity, $status, $page_size, $cursor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listIncidents'
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $severity (optional)
     * @param  string|null $status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listIncidents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listIncidentsRequest($property_id = null, $severity = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listIncidents'][0])
    {




        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listIncidents, must be smaller than or equal to 100.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listIncidents, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/incidents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $severity,
            'severity', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listMaintenanceRequests
     *
     * List maintenance requests
     *
     * @param  string|null $property_id property_id (optional)
     * @param  string|null $status status (optional)
     * @param  string|null $priority priority (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMaintenanceRequests'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetGuestStays200Response|\OpenAPI\Client\Model\Model0
     */
    public function listMaintenanceRequests($property_id = null, $status = null, $priority = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listMaintenanceRequests'][0])
    {
        list($response) = $this->listMaintenanceRequestsWithHttpInfo($property_id, $status, $priority, $page_size, $cursor, $contentType);
        return $response;
    }

    /**
     * Operation listMaintenanceRequestsWithHttpInfo
     *
     * List maintenance requests
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  string|null $priority (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMaintenanceRequests'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetGuestStays200Response|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function listMaintenanceRequestsWithHttpInfo($property_id = null, $status = null, $priority = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listMaintenanceRequests'][0])
    {
        $request = $this->listMaintenanceRequestsRequest($property_id, $status, $priority, $page_size, $cursor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetGuestStays200Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\GetGuestStays200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetGuestStays200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listMaintenanceRequestsAsync
     *
     * List maintenance requests
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  string|null $priority (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMaintenanceRequests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMaintenanceRequestsAsync($property_id = null, $status = null, $priority = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listMaintenanceRequests'][0])
    {
        return $this->listMaintenanceRequestsAsyncWithHttpInfo($property_id, $status, $priority, $page_size, $cursor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listMaintenanceRequestsAsyncWithHttpInfo
     *
     * List maintenance requests
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  string|null $priority (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMaintenanceRequests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listMaintenanceRequestsAsyncWithHttpInfo($property_id = null, $status = null, $priority = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listMaintenanceRequests'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetGuestStays200Response';
        $request = $this->listMaintenanceRequestsRequest($property_id, $status, $priority, $page_size, $cursor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listMaintenanceRequests'
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  string|null $priority (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listMaintenanceRequests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listMaintenanceRequestsRequest($property_id = null, $status = null, $priority = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listMaintenanceRequests'][0])
    {




        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listMaintenanceRequests, must be smaller than or equal to 100.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listMaintenanceRequests, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/maintenance/requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $priority,
            'priority', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listServiceRequests
     *
     * List service requests
     *
     * @param  string|null $property_id property_id (optional)
     * @param  string|null $status status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listServiceRequests'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetGuestStays200Response|\OpenAPI\Client\Model\Model0
     */
    public function listServiceRequests($property_id = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listServiceRequests'][0])
    {
        list($response) = $this->listServiceRequestsWithHttpInfo($property_id, $status, $page_size, $cursor, $contentType);
        return $response;
    }

    /**
     * Operation listServiceRequestsWithHttpInfo
     *
     * List service requests
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listServiceRequests'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetGuestStays200Response|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function listServiceRequestsWithHttpInfo($property_id = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listServiceRequests'][0])
    {
        $request = $this->listServiceRequestsRequest($property_id, $status, $page_size, $cursor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\GetGuestStays200Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\GetGuestStays200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetGuestStays200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listServiceRequestsAsync
     *
     * List service requests
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listServiceRequests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listServiceRequestsAsync($property_id = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listServiceRequests'][0])
    {
        return $this->listServiceRequestsAsyncWithHttpInfo($property_id, $status, $page_size, $cursor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listServiceRequestsAsyncWithHttpInfo
     *
     * List service requests
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listServiceRequests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listServiceRequestsAsyncWithHttpInfo($property_id = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listServiceRequests'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetGuestStays200Response';
        $request = $this->listServiceRequestsRequest($property_id, $status, $page_size, $cursor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listServiceRequests'
     *
     * @param  string|null $property_id (optional)
     * @param  string|null $status (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listServiceRequests'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listServiceRequestsRequest($property_id = null, $status = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listServiceRequests'][0])
    {



        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listServiceRequests, must be smaller than or equal to 100.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listServiceRequests, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/service-requests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $property_id,
            'propertyId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStaffShifts
     *
     * List staff shifts
     *
     * @param  string|null $staff_id staff_id (optional)
     * @param  \DateTime|null $date date (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStaffShifts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListStaffShifts200Response|\OpenAPI\Client\Model\Model0
     */
    public function listStaffShifts($staff_id = null, $date = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listStaffShifts'][0])
    {
        list($response) = $this->listStaffShiftsWithHttpInfo($staff_id, $date, $page_size, $cursor, $contentType);
        return $response;
    }

    /**
     * Operation listStaffShiftsWithHttpInfo
     *
     * List staff shifts
     *
     * @param  string|null $staff_id (optional)
     * @param  \DateTime|null $date (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStaffShifts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListStaffShifts200Response|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function listStaffShiftsWithHttpInfo($staff_id = null, $date = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listStaffShifts'][0])
    {
        $request = $this->listStaffShiftsRequest($staff_id, $date, $page_size, $cursor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ListStaffShifts200Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ListStaffShifts200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListStaffShifts200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listStaffShiftsAsync
     *
     * List staff shifts
     *
     * @param  string|null $staff_id (optional)
     * @param  \DateTime|null $date (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStaffShifts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStaffShiftsAsync($staff_id = null, $date = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listStaffShifts'][0])
    {
        return $this->listStaffShiftsAsyncWithHttpInfo($staff_id, $date, $page_size, $cursor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStaffShiftsAsyncWithHttpInfo
     *
     * List staff shifts
     *
     * @param  string|null $staff_id (optional)
     * @param  \DateTime|null $date (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStaffShifts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStaffShiftsAsyncWithHttpInfo($staff_id = null, $date = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listStaffShifts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListStaffShifts200Response';
        $request = $this->listStaffShiftsRequest($staff_id, $date, $page_size, $cursor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStaffShifts'
     *
     * @param  string|null $staff_id (optional)
     * @param  \DateTime|null $date (optional)
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listStaffShifts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listStaffShiftsRequest($staff_id = null, $date = null, $page_size = 20, $cursor = null, string $contentType = self::contentTypes['listStaffShifts'][0])
    {



        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listStaffShifts, must be smaller than or equal to 100.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listStaffShifts, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/staff/shifts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $staff_id,
            'staffId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listTrainingModules
     *
     * List training modules
     *
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTrainingModules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ListTrainingModules200Response|\OpenAPI\Client\Model\Model0
     */
    public function listTrainingModules($page_size = 20, $cursor = null, string $contentType = self::contentTypes['listTrainingModules'][0])
    {
        list($response) = $this->listTrainingModulesWithHttpInfo($page_size, $cursor, $contentType);
        return $response;
    }

    /**
     * Operation listTrainingModulesWithHttpInfo
     *
     * List training modules
     *
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTrainingModules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ListTrainingModules200Response|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function listTrainingModulesWithHttpInfo($page_size = 20, $cursor = null, string $contentType = self::contentTypes['listTrainingModules'][0])
    {
        $request = $this->listTrainingModulesRequest($page_size, $cursor, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ListTrainingModules200Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ListTrainingModules200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ListTrainingModules200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listTrainingModulesAsync
     *
     * List training modules
     *
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTrainingModules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTrainingModulesAsync($page_size = 20, $cursor = null, string $contentType = self::contentTypes['listTrainingModules'][0])
    {
        return $this->listTrainingModulesAsyncWithHttpInfo($page_size, $cursor, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listTrainingModulesAsyncWithHttpInfo
     *
     * List training modules
     *
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTrainingModules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listTrainingModulesAsyncWithHttpInfo($page_size = 20, $cursor = null, string $contentType = self::contentTypes['listTrainingModules'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ListTrainingModules200Response';
        $request = $this->listTrainingModulesRequest($page_size, $cursor, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listTrainingModules'
     *
     * @param  int|null $page_size Number of items per page (max 100) (optional, default to 20)
     * @param  string|null $cursor Cursor for pagination (opaque token) (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listTrainingModules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listTrainingModulesRequest($page_size = 20, $cursor = null, string $contentType = self::contentTypes['listTrainingModules'][0])
    {

        if ($page_size !== null && $page_size > 100) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listTrainingModules, must be smaller than or equal to 100.');
        }
        if ($page_size !== null && $page_size < 1) {
            throw new \InvalidArgumentException('invalid value for "$page_size" when calling OperationsApi.listTrainingModules, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/training/modules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cursor,
            'cursor', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceHousekeepingTask
     *
     * Replace housekeeping task (full update)
     *
     * @param  string $task_id task_id (required)
     * @param  object $body body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function replaceHousekeepingTask($task_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceHousekeepingTask'][0])
    {
        list($response) = $this->replaceHousekeepingTaskWithHttpInfo($task_id, $body, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation replaceHousekeepingTaskWithHttpInfo
     *
     * Replace housekeeping task (full update)
     *
     * @param  string $task_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceHousekeepingTaskWithHttpInfo($task_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceHousekeepingTask'][0])
    {
        $request = $this->replaceHousekeepingTaskRequest($task_id, $body, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation replaceHousekeepingTaskAsync
     *
     * Replace housekeeping task (full update)
     *
     * @param  string $task_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceHousekeepingTaskAsync($task_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceHousekeepingTask'][0])
    {
        return $this->replaceHousekeepingTaskAsyncWithHttpInfo($task_id, $body, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceHousekeepingTaskAsyncWithHttpInfo
     *
     * Replace housekeeping task (full update)
     *
     * @param  string $task_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceHousekeepingTaskAsyncWithHttpInfo($task_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceHousekeepingTask'][0])
    {
        $returnType = 'object';
        $request = $this->replaceHousekeepingTaskRequest($task_id, $body, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceHousekeepingTask'
     *
     * @param  string $task_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function replaceHousekeepingTaskRequest($task_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceHousekeepingTask'][0])
    {

        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling replaceHousekeepingTask'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceHousekeepingTask'
            );
        }



        $resourcePath = '/housekeeping/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceIncident
     *
     * Replace incident (full update)
     *
     * @param  string $incident_id incident_id (required)
     * @param  \OpenAPI\Client\Model\Incident $incident incident (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceIncident'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function replaceIncident($incident_id, $incident, $if_match = null, string $contentType = self::contentTypes['replaceIncident'][0])
    {
        list($response) = $this->replaceIncidentWithHttpInfo($incident_id, $incident, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation replaceIncidentWithHttpInfo
     *
     * Replace incident (full update)
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\Incident $incident (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceIncident'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceIncidentWithHttpInfo($incident_id, $incident, $if_match = null, string $contentType = self::contentTypes['replaceIncident'][0])
    {
        $request = $this->replaceIncidentRequest($incident_id, $incident, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Incident',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\Incident',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Incident',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation replaceIncidentAsync
     *
     * Replace incident (full update)
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\Incident $incident (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceIncidentAsync($incident_id, $incident, $if_match = null, string $contentType = self::contentTypes['replaceIncident'][0])
    {
        return $this->replaceIncidentAsyncWithHttpInfo($incident_id, $incident, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceIncidentAsyncWithHttpInfo
     *
     * Replace incident (full update)
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\Incident $incident (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceIncidentAsyncWithHttpInfo($incident_id, $incident, $if_match = null, string $contentType = self::contentTypes['replaceIncident'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Incident';
        $request = $this->replaceIncidentRequest($incident_id, $incident, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceIncident'
     *
     * @param  string $incident_id (required)
     * @param  \OpenAPI\Client\Model\Incident $incident (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function replaceIncidentRequest($incident_id, $incident, $if_match = null, string $contentType = self::contentTypes['replaceIncident'][0])
    {

        // verify the required parameter 'incident_id' is set
        if ($incident_id === null || (is_array($incident_id) && count($incident_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $incident_id when calling replaceIncident'
            );
        }

        // verify the required parameter 'incident' is set
        if ($incident === null || (is_array($incident) && count($incident) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $incident when calling replaceIncident'
            );
        }



        $resourcePath = '/incidents/{incidentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($incident_id !== null) {
            $resourcePath = str_replace(
                '{' . 'incidentId' . '}',
                ObjectSerializer::toPathValue($incident_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($incident)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($incident));
            } else {
                $httpBody = $incident;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceMaintenanceRequest
     *
     * Replace maintenance request (full update)
     *
     * @param  string $request_id request_id (required)
     * @param  object $body body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function replaceMaintenanceRequest($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceMaintenanceRequest'][0])
    {
        list($response) = $this->replaceMaintenanceRequestWithHttpInfo($request_id, $body, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation replaceMaintenanceRequestWithHttpInfo
     *
     * Replace maintenance request (full update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceMaintenanceRequestWithHttpInfo($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceMaintenanceRequest'][0])
    {
        $request = $this->replaceMaintenanceRequestRequest($request_id, $body, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation replaceMaintenanceRequestAsync
     *
     * Replace maintenance request (full update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceMaintenanceRequestAsync($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceMaintenanceRequest'][0])
    {
        return $this->replaceMaintenanceRequestAsyncWithHttpInfo($request_id, $body, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceMaintenanceRequestAsyncWithHttpInfo
     *
     * Replace maintenance request (full update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceMaintenanceRequestAsyncWithHttpInfo($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceMaintenanceRequest'][0])
    {
        $returnType = 'object';
        $request = $this->replaceMaintenanceRequestRequest($request_id, $body, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceMaintenanceRequest'
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function replaceMaintenanceRequestRequest($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceMaintenanceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling replaceMaintenanceRequest'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceMaintenanceRequest'
            );
        }



        $resourcePath = '/maintenance/requests/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceServiceRequest
     *
     * Replace service request (full update)
     *
     * @param  string $request_id request_id (required)
     * @param  object $body body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function replaceServiceRequest($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceServiceRequest'][0])
    {
        list($response) = $this->replaceServiceRequestWithHttpInfo($request_id, $body, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation replaceServiceRequestWithHttpInfo
     *
     * Replace service request (full update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceServiceRequestWithHttpInfo($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceServiceRequest'][0])
    {
        $request = $this->replaceServiceRequestRequest($request_id, $body, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation replaceServiceRequestAsync
     *
     * Replace service request (full update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceServiceRequestAsync($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceServiceRequest'][0])
    {
        return $this->replaceServiceRequestAsyncWithHttpInfo($request_id, $body, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceServiceRequestAsyncWithHttpInfo
     *
     * Replace service request (full update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceServiceRequestAsyncWithHttpInfo($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceServiceRequest'][0])
    {
        $returnType = 'object';
        $request = $this->replaceServiceRequestRequest($request_id, $body, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceServiceRequest'
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['replaceServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function replaceServiceRequestRequest($request_id, $body, $if_match = null, string $contentType = self::contentTypes['replaceServiceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling replaceServiceRequest'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceServiceRequest'
            );
        }



        $resourcePath = '/service-requests/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reportIncident
     *
     * Report incident
     *
     * @param  \OpenAPI\Client\Model\Incident $incident incident (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportIncident'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function reportIncident($incident, string $contentType = self::contentTypes['reportIncident'][0])
    {
        list($response) = $this->reportIncidentWithHttpInfo($incident, $contentType);
        return $response;
    }

    /**
     * Operation reportIncidentWithHttpInfo
     *
     * Report incident
     *
     * @param  \OpenAPI\Client\Model\Incident $incident (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportIncident'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Incident|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function reportIncidentWithHttpInfo($incident, string $contentType = self::contentTypes['reportIncident'][0])
    {
        $request = $this->reportIncidentRequest($incident, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Incident',
                        $request,
                        $response,
                    );
                case 400:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\Incident',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Incident',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation reportIncidentAsync
     *
     * Report incident
     *
     * @param  \OpenAPI\Client\Model\Incident $incident (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportIncidentAsync($incident, string $contentType = self::contentTypes['reportIncident'][0])
    {
        return $this->reportIncidentAsyncWithHttpInfo($incident, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reportIncidentAsyncWithHttpInfo
     *
     * Report incident
     *
     * @param  \OpenAPI\Client\Model\Incident $incident (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reportIncidentAsyncWithHttpInfo($incident, string $contentType = self::contentTypes['reportIncident'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Incident';
        $request = $this->reportIncidentRequest($incident, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reportIncident'
     *
     * @param  \OpenAPI\Client\Model\Incident $incident (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reportIncident'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reportIncidentRequest($incident, string $contentType = self::contentTypes['reportIncident'][0])
    {

        // verify the required parameter 'incident' is set
        if ($incident === null || (is_array($incident) && count($incident) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $incident when calling reportIncident'
            );
        }


        $resourcePath = '/incidents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($incident)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($incident));
            } else {
                $httpBody = $incident;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startHousekeepingTask
     *
     * Start housekeeping task
     *
     * @param  string $task_id task_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function startHousekeepingTask($task_id, string $contentType = self::contentTypes['startHousekeepingTask'][0])
    {
        list($response) = $this->startHousekeepingTaskWithHttpInfo($task_id, $contentType);
        return $response;
    }

    /**
     * Operation startHousekeepingTaskWithHttpInfo
     *
     * Start housekeeping task
     *
     * @param  string $task_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function startHousekeepingTaskWithHttpInfo($task_id, string $contentType = self::contentTypes['startHousekeepingTask'][0])
    {
        $request = $this->startHousekeepingTaskRequest($task_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HousekeepingTask',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation startHousekeepingTaskAsync
     *
     * Start housekeeping task
     *
     * @param  string $task_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startHousekeepingTaskAsync($task_id, string $contentType = self::contentTypes['startHousekeepingTask'][0])
    {
        return $this->startHousekeepingTaskAsyncWithHttpInfo($task_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startHousekeepingTaskAsyncWithHttpInfo
     *
     * Start housekeeping task
     *
     * @param  string $task_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startHousekeepingTaskAsyncWithHttpInfo($task_id, string $contentType = self::contentTypes['startHousekeepingTask'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HousekeepingTask';
        $request = $this->startHousekeepingTaskRequest($task_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startHousekeepingTask'
     *
     * @param  string $task_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function startHousekeepingTaskRequest($task_id, string $contentType = self::contentTypes['startHousekeepingTask'][0])
    {

        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling startHousekeepingTask'
            );
        }


        $resourcePath = '/housekeeping/tasks/{taskId}/start';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateHousekeepingTask
     *
     * Update housekeeping task (partial update)
     *
     * @param  string $task_id task_id (required)
     * @param  object $body body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function updateHousekeepingTask($task_id, $body, $if_match = null, string $contentType = self::contentTypes['updateHousekeepingTask'][0])
    {
        list($response) = $this->updateHousekeepingTaskWithHttpInfo($task_id, $body, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation updateHousekeepingTaskWithHttpInfo
     *
     * Update housekeeping task (partial update)
     *
     * @param  string $task_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateHousekeepingTaskWithHttpInfo($task_id, $body, $if_match = null, string $contentType = self::contentTypes['updateHousekeepingTask'][0])
    {
        $request = $this->updateHousekeepingTaskRequest($task_id, $body, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateHousekeepingTaskAsync
     *
     * Update housekeeping task (partial update)
     *
     * @param  string $task_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHousekeepingTaskAsync($task_id, $body, $if_match = null, string $contentType = self::contentTypes['updateHousekeepingTask'][0])
    {
        return $this->updateHousekeepingTaskAsyncWithHttpInfo($task_id, $body, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateHousekeepingTaskAsyncWithHttpInfo
     *
     * Update housekeeping task (partial update)
     *
     * @param  string $task_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateHousekeepingTaskAsyncWithHttpInfo($task_id, $body, $if_match = null, string $contentType = self::contentTypes['updateHousekeepingTask'][0])
    {
        $returnType = 'object';
        $request = $this->updateHousekeepingTaskRequest($task_id, $body, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateHousekeepingTask'
     *
     * @param  string $task_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateHousekeepingTaskRequest($task_id, $body, $if_match = null, string $contentType = self::contentTypes['updateHousekeepingTask'][0])
    {

        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling updateHousekeepingTask'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateHousekeepingTask'
            );
        }



        $resourcePath = '/housekeeping/tasks/{taskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateMaintenanceRequest
     *
     * Update maintenance request (partial update)
     *
     * @param  string $request_id request_id (required)
     * @param  object $body body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function updateMaintenanceRequest($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateMaintenanceRequest'][0])
    {
        list($response) = $this->updateMaintenanceRequestWithHttpInfo($request_id, $body, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation updateMaintenanceRequestWithHttpInfo
     *
     * Update maintenance request (partial update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateMaintenanceRequestWithHttpInfo($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateMaintenanceRequest'][0])
    {
        $request = $this->updateMaintenanceRequestRequest($request_id, $body, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateMaintenanceRequestAsync
     *
     * Update maintenance request (partial update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMaintenanceRequestAsync($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateMaintenanceRequest'][0])
    {
        return $this->updateMaintenanceRequestAsyncWithHttpInfo($request_id, $body, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateMaintenanceRequestAsyncWithHttpInfo
     *
     * Update maintenance request (partial update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateMaintenanceRequestAsyncWithHttpInfo($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateMaintenanceRequest'][0])
    {
        $returnType = 'object';
        $request = $this->updateMaintenanceRequestRequest($request_id, $body, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateMaintenanceRequest'
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateMaintenanceRequestRequest($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateMaintenanceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling updateMaintenanceRequest'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateMaintenanceRequest'
            );
        }



        $resourcePath = '/maintenance/requests/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateServiceRequest
     *
     * Update service request (partial update)
     *
     * @param  string $request_id request_id (required)
     * @param  object $body body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function updateServiceRequest($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateServiceRequest'][0])
    {
        list($response) = $this->updateServiceRequestWithHttpInfo($request_id, $body, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation updateServiceRequestWithHttpInfo
     *
     * Update service request (partial update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateServiceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateServiceRequestWithHttpInfo($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateServiceRequest'][0])
    {
        $request = $this->updateServiceRequestRequest($request_id, $body, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 412:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 412:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateServiceRequestAsync
     *
     * Update service request (partial update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateServiceRequestAsync($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateServiceRequest'][0])
    {
        return $this->updateServiceRequestAsyncWithHttpInfo($request_id, $body, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateServiceRequestAsyncWithHttpInfo
     *
     * Update service request (partial update)
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateServiceRequestAsyncWithHttpInfo($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateServiceRequest'][0])
    {
        $returnType = 'object';
        $request = $this->updateServiceRequestRequest($request_id, $body, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateServiceRequest'
     *
     * @param  string $request_id (required)
     * @param  object $body (required)
     * @param  string|null $if_match ETag for optimistic locking (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateServiceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateServiceRequestRequest($request_id, $body, $if_match = null, string $contentType = self::contentTypes['updateServiceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling updateServiceRequest'
            );
        }

        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateServiceRequest'
            );
        }



        $resourcePath = '/service-requests/{requestId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($body));
            } else {
                $httpBody = $body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyHousekeepingTask
     *
     * Verify housekeeping task
     *
     * @param  string $task_id task_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function verifyHousekeepingTask($task_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyHousekeepingTask'][0])
    {
        list($response) = $this->verifyHousekeepingTaskWithHttpInfo($task_id, $verify_housekeeping_task_request, $contentType);
        return $response;
    }

    /**
     * Operation verifyHousekeepingTaskWithHttpInfo
     *
     * Verify housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HousekeepingTask|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyHousekeepingTaskWithHttpInfo($task_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyHousekeepingTask'][0])
    {
        $request = $this->verifyHousekeepingTaskRequest($task_id, $verify_housekeeping_task_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HousekeepingTask',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HousekeepingTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation verifyHousekeepingTaskAsync
     *
     * Verify housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyHousekeepingTaskAsync($task_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyHousekeepingTask'][0])
    {
        return $this->verifyHousekeepingTaskAsyncWithHttpInfo($task_id, $verify_housekeeping_task_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyHousekeepingTaskAsyncWithHttpInfo
     *
     * Verify housekeeping task
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyHousekeepingTaskAsyncWithHttpInfo($task_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyHousekeepingTask'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HousekeepingTask';
        $request = $this->verifyHousekeepingTaskRequest($task_id, $verify_housekeeping_task_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyHousekeepingTask'
     *
     * @param  string $task_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyHousekeepingTask'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function verifyHousekeepingTaskRequest($task_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyHousekeepingTask'][0])
    {

        // verify the required parameter 'task_id' is set
        if ($task_id === null || (is_array($task_id) && count($task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $task_id when calling verifyHousekeepingTask'
            );
        }



        $resourcePath = '/housekeeping/tasks/{taskId}/verify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'taskId' . '}',
                ObjectSerializer::toPathValue($task_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($verify_housekeeping_task_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($verify_housekeeping_task_request));
            } else {
                $httpBody = $verify_housekeeping_task_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyMaintenanceRequest
     *
     * Verify maintenance completion
     *
     * @param  string $request_id request_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MaintenanceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0
     */
    public function verifyMaintenanceRequest($request_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyMaintenanceRequest'][0])
    {
        list($response) = $this->verifyMaintenanceRequestWithHttpInfo($request_id, $verify_housekeeping_task_request, $contentType);
        return $response;
    }

    /**
     * Operation verifyMaintenanceRequestWithHttpInfo
     *
     * Verify maintenance completion
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MaintenanceRequest|\OpenAPI\Client\Model\Model0|\OpenAPI\Client\Model\Model0, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyMaintenanceRequestWithHttpInfo($request_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyMaintenanceRequest'][0])
    {
        $request = $this->verifyMaintenanceRequestRequest($request_id, $verify_housekeeping_task_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MaintenanceRequest',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Model0',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MaintenanceRequest',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MaintenanceRequest',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Model0',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation verifyMaintenanceRequestAsync
     *
     * Verify maintenance completion
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyMaintenanceRequestAsync($request_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyMaintenanceRequest'][0])
    {
        return $this->verifyMaintenanceRequestAsyncWithHttpInfo($request_id, $verify_housekeeping_task_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyMaintenanceRequestAsyncWithHttpInfo
     *
     * Verify maintenance completion
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyMaintenanceRequestAsyncWithHttpInfo($request_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyMaintenanceRequest'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MaintenanceRequest';
        $request = $this->verifyMaintenanceRequestRequest($request_id, $verify_housekeeping_task_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyMaintenanceRequest'
     *
     * @param  string $request_id (required)
     * @param  \OpenAPI\Client\Model\VerifyHousekeepingTaskRequest|null $verify_housekeeping_task_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyMaintenanceRequest'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function verifyMaintenanceRequestRequest($request_id, $verify_housekeeping_task_request = null, string $contentType = self::contentTypes['verifyMaintenanceRequest'][0])
    {

        // verify the required parameter 'request_id' is set
        if ($request_id === null || (is_array($request_id) && count($request_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_id when calling verifyMaintenanceRequest'
            );
        }



        $resourcePath = '/maintenance/requests/{requestId}/verify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($request_id !== null) {
            $resourcePath = str_replace(
                '{' . 'requestId' . '}',
                ObjectSerializer::toPathValue($request_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/problem+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($verify_housekeeping_task_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($verify_housekeeping_task_request));
            } else {
                $httpBody = $verify_housekeeping_task_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
